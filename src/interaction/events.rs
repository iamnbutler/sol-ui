//! Interaction event types and state

use super::ElementId;
use crate::layer::MouseButton;
use glam::Vec2;

/// Events generated by the interaction system
#[derive(Debug, Clone)]
pub enum InteractionEvent {
    /// Mouse entered an element
    MouseEnter { element_id: ElementId },

    /// Mouse left an element
    MouseLeave { element_id: ElementId },

    /// Mouse moved over an element
    MouseMove {
        element_id: ElementId,
        position: Vec2,
        local_position: Vec2,
    },

    /// Mouse button pressed on an element
    MouseDown {
        element_id: ElementId,
        button: MouseButton,
        position: Vec2,
        local_position: Vec2,
    },

    /// Mouse button released on an element
    MouseUp {
        element_id: ElementId,
        button: MouseButton,
        position: Vec2,
        local_position: Vec2,
    },

    /// Click event (mouse down + up on same element)
    Click {
        element_id: ElementId,
        button: MouseButton,
        position: Vec2,
        local_position: Vec2,
    },
}

/// Current interaction state of an element
#[derive(Debug, Clone, Default)]
pub struct InteractionState {
    /// Whether the mouse is currently hovering over the element
    pub is_hovered: bool,

    /// Whether a mouse button is currently pressed on the element
    pub is_pressed: bool,
}

impl InteractionState {
    pub fn new() -> Self {
        Self::default()
    }
}

/// Handler trait for interaction events
pub trait InteractionHandler {
    /// Called when mouse enters the element
    fn on_mouse_enter(&mut self) {}

    /// Called when mouse leaves the element
    fn on_mouse_leave(&mut self) {}

    /// Called when mouse moves over the element
    fn on_mouse_move(&mut self, _position: Vec2, _local_position: Vec2) {}

    /// Called when mouse button is pressed on the element
    fn on_mouse_down(&mut self, _button: MouseButton, _position: Vec2, _local_position: Vec2) {}

    /// Called when mouse button is released on the element
    fn on_mouse_up(&mut self, _button: MouseButton, _position: Vec2, _local_position: Vec2) {}

    /// Called when element is clicked
    fn on_click(&mut self, _button: MouseButton, _position: Vec2, _local_position: Vec2) {}
}

/// Event handler closures for interactive elements
pub struct EventHandlers {
    pub on_mouse_enter: Option<Box<dyn FnMut()>>,
    pub on_mouse_leave: Option<Box<dyn FnMut()>>,
    pub on_mouse_move: Option<Box<dyn FnMut(Vec2, Vec2)>>,
    pub on_mouse_down: Option<Box<dyn FnMut(MouseButton, Vec2, Vec2)>>,
    pub on_mouse_up: Option<Box<dyn FnMut(MouseButton, Vec2, Vec2)>>,
    pub on_click: Option<Box<dyn FnMut(MouseButton, Vec2, Vec2)>>,
}

impl EventHandlers {
    pub fn new() -> Self {
        Self {
            on_mouse_enter: None,
            on_mouse_leave: None,
            on_mouse_move: None,
            on_mouse_down: None,
            on_mouse_up: None,
            on_click: None,
        }
    }

    /// Set the mouse enter handler
    pub fn on_mouse_enter<F>(mut self, handler: F) -> Self
    where
        F: FnMut() + 'static,
    {
        self.on_mouse_enter = Some(Box::new(handler));
        self
    }

    /// Set the mouse leave handler
    pub fn on_mouse_leave<F>(mut self, handler: F) -> Self
    where
        F: FnMut() + 'static,
    {
        self.on_mouse_leave = Some(Box::new(handler));
        self
    }

    /// Set the mouse move handler
    pub fn on_mouse_move<F>(mut self, handler: F) -> Self
    where
        F: FnMut(Vec2, Vec2) + 'static,
    {
        self.on_mouse_move = Some(Box::new(handler));
        self
    }

    /// Set the mouse down handler
    pub fn on_mouse_down<F>(mut self, handler: F) -> Self
    where
        F: FnMut(MouseButton, Vec2, Vec2) + 'static,
    {
        self.on_mouse_down = Some(Box::new(handler));
        self
    }

    /// Set the mouse up handler
    pub fn on_mouse_up<F>(mut self, handler: F) -> Self
    where
        F: FnMut(MouseButton, Vec2, Vec2) + 'static,
    {
        self.on_mouse_up = Some(Box::new(handler));
        self
    }

    /// Set the click handler
    pub fn on_click<F>(mut self, handler: F) -> Self
    where
        F: FnMut(MouseButton, Vec2, Vec2) + 'static,
    {
        self.on_click = Some(Box::new(handler));
        self
    }

    /// Process an interaction event
    pub fn handle_event(&mut self, event: &InteractionEvent) {
        match event {
            InteractionEvent::MouseEnter { .. } => {
                if let Some(handler) = &mut self.on_mouse_enter {
                    handler();
                }
            }
            InteractionEvent::MouseLeave { .. } => {
                if let Some(handler) = &mut self.on_mouse_leave {
                    handler();
                }
            }
            InteractionEvent::MouseMove {
                position,
                local_position,
                ..
            } => {
                if let Some(handler) = &mut self.on_mouse_move {
                    handler(*position, *local_position);
                }
            }
            InteractionEvent::MouseDown {
                button,
                position,
                local_position,
                ..
            } => {
                if let Some(handler) = &mut self.on_mouse_down {
                    handler(*button, *position, *local_position);
                }
            }
            InteractionEvent::MouseUp {
                button,
                position,
                local_position,
                ..
            } => {
                if let Some(handler) = &mut self.on_mouse_up {
                    handler(*button, *position, *local_position);
                }
            }
            InteractionEvent::Click {
                button,
                position,
                local_position,
                ..
            } => {
                if let Some(handler) = &mut self.on_click {
                    handler(*button, *position, *local_position);
                }
            }
        }
    }
}

impl Default for EventHandlers {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::layer::MouseButton;
    use glam::Vec2;

    #[test]
    fn test_interaction_event_creation() {
        let element_id = ElementId::from(123);
        let position = Vec2::new(10.0, 20.0);
        let local_position = Vec2::new(5.0, 15.0);
        let button = MouseButton::Left;

        let mouse_enter = InteractionEvent::MouseEnter { element_id };
        let mouse_leave = InteractionEvent::MouseLeave { element_id };
        let mouse_move = InteractionEvent::MouseMove {
            element_id,
            position,
            local_position,
        };
        let mouse_down = InteractionEvent::MouseDown {
            element_id,
            button,
            position,
            local_position,
        };
        let mouse_up = InteractionEvent::MouseUp {
            element_id,
            button,
            position,
            local_position,
        };
        let click = InteractionEvent::Click {
            element_id,
            button,
            position,
            local_position,
        };

        // Test that events can be created and matched
        match mouse_enter {
            InteractionEvent::MouseEnter { element_id } => assert_eq!(element_id, ElementId::from(123)),
            _ => panic!("Wrong event type"),
        }

        match mouse_move {
            InteractionEvent::MouseMove { element_id, position, local_position } => {
                assert_eq!(element_id, ElementId::from(123));
                assert_eq!(position, Vec2::new(10.0, 20.0));
                assert_eq!(local_position, Vec2::new(5.0, 15.0));
            }
            _ => panic!("Wrong event type"),
        }

        match click {
            InteractionEvent::Click { element_id, button, .. } => {
                assert_eq!(element_id, ElementId::from(123));
                assert_eq!(button, MouseButton::Left);
            }
            _ => panic!("Wrong event type"),
        }
    }

    #[test]
    fn test_interaction_state_creation() {
        let state = InteractionState::new();
        assert!(!state.is_hovered);
        assert!(!state.is_pressed);

        let default_state = InteractionState::default();
        assert!(!default_state.is_hovered);
        assert!(!default_state.is_pressed);
    }

    #[test]
    fn test_interaction_state_modification() {
        let mut state = InteractionState::new();
        
        state.is_hovered = true;
        assert!(state.is_hovered);
        assert!(!state.is_pressed);

        state.is_pressed = true;
        assert!(state.is_hovered);
        assert!(state.is_pressed);

        state.is_hovered = false;
        assert!(!state.is_hovered);
        assert!(state.is_pressed);
    }

    #[test]
    fn test_event_handlers_creation() {
        let handlers = EventHandlers::new();
        assert!(handlers.on_mouse_enter.is_none());
        assert!(handlers.on_mouse_leave.is_none());
        assert!(handlers.on_mouse_move.is_none());
        assert!(handlers.on_mouse_down.is_none());
        assert!(handlers.on_mouse_up.is_none());
        assert!(handlers.on_click.is_none());

        let default_handlers = EventHandlers::default();
        assert!(default_handlers.on_mouse_enter.is_none());
    }

    #[test]
    fn test_event_handlers_builder_pattern() {
        let mut handlers = EventHandlers::new()
            .on_mouse_enter(|| {})
            .on_mouse_leave(|| {})
            .on_mouse_move(|_, _| {})
            .on_mouse_down(|_, _, _| {})
            .on_mouse_up(|_, _, _| {})
            .on_click(|_, _, _| {});

        assert!(handlers.on_mouse_enter.is_some());
        assert!(handlers.on_mouse_leave.is_some());
        assert!(handlers.on_mouse_move.is_some());
        assert!(handlers.on_mouse_down.is_some());
        assert!(handlers.on_mouse_up.is_some());
        assert!(handlers.on_click.is_some());
    }

    #[test]
    fn test_event_handlers_execution() {
        use std::sync::{Arc, Mutex};

        let call_count = Arc::new(Mutex::new(0));
        let call_count_clone = call_count.clone();

        let mut handlers = EventHandlers::new()
            .on_mouse_enter(move || {
                *call_count_clone.lock().unwrap() += 1;
            });

        let event = InteractionEvent::MouseEnter { element_id: ElementId::from(1) };
        handlers.handle_event(&event);

        assert_eq!(*call_count.lock().unwrap(), 1);
    }

    #[test]
    fn test_event_handlers_mouse_move() {
        use std::sync::{Arc, Mutex};

        let positions = Arc::new(Mutex::new(Vec::new()));
        let positions_clone = positions.clone();

        let mut handlers = EventHandlers::new()
            .on_mouse_move(move |pos, local_pos| {
                positions_clone.lock().unwrap().push((pos, local_pos));
            });

        let event = InteractionEvent::MouseMove {
            element_id: ElementId::from(1),
            position: Vec2::new(100.0, 200.0),
            local_position: Vec2::new(50.0, 100.0),
        };

        handlers.handle_event(&event);

        let captured_positions = positions.lock().unwrap();
        assert_eq!(captured_positions.len(), 1);
        assert_eq!(captured_positions[0], (Vec2::new(100.0, 200.0), Vec2::new(50.0, 100.0)));
    }

    #[test]
    fn test_event_handlers_click() {
        use std::sync::{Arc, Mutex};

        let clicks = Arc::new(Mutex::new(Vec::new()));
        let clicks_clone = clicks.clone();

        let mut handlers = EventHandlers::new()
            .on_click(move |button, pos, local_pos| {
                clicks_clone.lock().unwrap().push((button, pos, local_pos));
            });

        let event = InteractionEvent::Click {
            element_id: ElementId::from(1),
            button: MouseButton::Right,
            position: Vec2::new(75.0, 125.0),
            local_position: Vec2::new(25.0, 75.0),
        };

        handlers.handle_event(&event);

        let captured_clicks = clicks.lock().unwrap();
        assert_eq!(captured_clicks.len(), 1);
        assert_eq!(captured_clicks[0], (MouseButton::Right, Vec2::new(75.0, 125.0), Vec2::new(25.0, 75.0)));
    }

    #[test]
    fn test_event_handlers_no_handler_set() {
        let mut handlers = EventHandlers::new();
        
        // Should not panic when no handlers are set
        let event = InteractionEvent::MouseEnter { element_id: ElementId::from(1) };
        handlers.handle_event(&event);

        let event = InteractionEvent::Click {
            element_id: ElementId::from(1),
            button: MouseButton::Left,
            position: Vec2::ZERO,
            local_position: Vec2::ZERO,
        };
        handlers.handle_event(&event);
    }

    #[test]
    fn test_interaction_event_clone() {
        let event = InteractionEvent::MouseMove {
            element_id: ElementId::from(42),
            position: Vec2::new(10.0, 20.0),
            local_position: Vec2::new(5.0, 15.0),
        };

        let cloned = event.clone();
        
        match (event, cloned) {
            (InteractionEvent::MouseMove { element_id: id1, position: pos1, .. },
             InteractionEvent::MouseMove { element_id: id2, position: pos2, .. }) => {
                assert_eq!(id1, id2);
                assert_eq!(pos1, pos2);
            }
            _ => panic!("Clone failed"),
        }
    }

    #[test]
    fn test_interaction_state_clone() {
        let mut state = InteractionState::new();
        state.is_hovered = true;
        state.is_pressed = false;

        let cloned = state.clone();
        assert_eq!(state.is_hovered, cloned.is_hovered);
        assert_eq!(state.is_pressed, cloned.is_pressed);
    }

    #[test]
    fn test_event_handlers_partial_setup() {
        use std::sync::{Arc, Mutex};

        let enter_count = Arc::new(Mutex::new(0));
        let leave_count = Arc::new(Mutex::new(0));
        
        let enter_clone = enter_count.clone();
        let leave_clone = leave_count.clone();

        let mut handlers = EventHandlers::new()
            .on_mouse_enter(move || { *enter_clone.lock().unwrap() += 1; })
            .on_mouse_leave(move || { *leave_clone.lock().unwrap() += 1; });
        
        // Test enter event
        handlers.handle_event(&InteractionEvent::MouseEnter { element_id: ElementId::from(1) });
        assert_eq!(*enter_count.lock().unwrap(), 1);
        assert_eq!(*leave_count.lock().unwrap(), 0);

        // Test leave event
        handlers.handle_event(&InteractionEvent::MouseLeave { element_id: ElementId::from(1) });
        assert_eq!(*enter_count.lock().unwrap(), 1);
        assert_eq!(*leave_count.lock().unwrap(), 1);

        // Test unhandled event (should not panic)
        handlers.handle_event(&InteractionEvent::Click {
            element_id: ElementId::from(1),
            button: MouseButton::Left,
            position: Vec2::ZERO,
            local_position: Vec2::ZERO,
        });
        assert_eq!(*enter_count.lock().unwrap(), 1);
        assert_eq!(*leave_count.lock().unwrap(), 1);
    }
}
