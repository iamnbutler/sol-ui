//! Interaction event types and state

use super::{ElementId, ShortcutId};
use crate::layer::{Key, Modifiers, MouseButton};
use glam::Vec2;

/// Events generated by the interaction system
#[derive(Debug, Clone)]
pub enum InteractionEvent {
    // --- Mouse Events ---

    /// Mouse entered an element
    MouseEnter { element_id: ElementId },

    /// Mouse left an element
    MouseLeave { element_id: ElementId },

    /// Mouse moved over an element
    MouseMove {
        element_id: ElementId,
        position: Vec2,
        local_position: Vec2,
    },

    /// Mouse button pressed on an element
    MouseDown {
        element_id: ElementId,
        button: MouseButton,
        position: Vec2,
        local_position: Vec2,
    },

    /// Mouse button released on an element
    MouseUp {
        element_id: ElementId,
        button: MouseButton,
        position: Vec2,
        local_position: Vec2,
    },

    /// Click event (mouse down + up on same element)
    Click {
        element_id: ElementId,
        button: MouseButton,
        position: Vec2,
        local_position: Vec2,
    },

    /// Scroll wheel event on an element
    ScrollWheel {
        element_id: ElementId,
        delta: Vec2,
        position: Vec2,
        local_position: Vec2,
    },

    // --- Keyboard Events ---

    /// Key pressed on focused element
    KeyDown {
        element_id: ElementId,
        key: Key,
        modifiers: Modifiers,
        /// The character produced by this key press (if any)
        character: Option<char>,
        /// Whether this is a key repeat event
        is_repeat: bool,
    },

    /// Key released on focused element
    KeyUp {
        element_id: ElementId,
        key: Key,
        modifiers: Modifiers,
    },

    // --- Focus Events ---

    /// Element gained focus
    FocusIn { element_id: ElementId },

    /// Element lost focus
    FocusOut { element_id: ElementId },

    // --- Shortcut Events ---

    /// A keyboard shortcut was triggered
    ShortcutTriggered {
        /// The shortcut ID that was triggered
        shortcut_id: ShortcutId,
        /// The action name (e.g., "copy", "save")
        action_name: String,
    },
}

/// Current interaction state of an element
#[derive(Debug, Clone, Default)]
pub struct InteractionState {
    /// Whether the mouse is currently hovering over the element
    pub is_hovered: bool,

    /// Whether a mouse button is currently pressed on the element
    pub is_pressed: bool,

    /// Whether the element currently has keyboard focus
    pub is_focused: bool,
}

impl InteractionState {
    pub fn new() -> Self {
        Self::default()
    }
}

/// Handler trait for interaction events
pub trait InteractionHandler {
    // Mouse handlers
    /// Called when mouse enters the element
    fn on_mouse_enter(&mut self) {}

    /// Called when mouse leaves the element
    fn on_mouse_leave(&mut self) {}

    /// Called when mouse moves over the element
    fn on_mouse_move(&mut self, _position: Vec2, _local_position: Vec2) {}

    /// Called when mouse button is pressed on the element
    fn on_mouse_down(&mut self, _button: MouseButton, _position: Vec2, _local_position: Vec2) {}

    /// Called when mouse button is released on the element
    fn on_mouse_up(&mut self, _button: MouseButton, _position: Vec2, _local_position: Vec2) {}

    /// Called when element is clicked
    fn on_click(&mut self, _button: MouseButton, _position: Vec2, _local_position: Vec2) {}

    // Keyboard handlers
    /// Called when a key is pressed while element has focus
    fn on_key_down(&mut self, _key: Key, _modifiers: Modifiers, _character: Option<char>, _is_repeat: bool) {}

    /// Called when a key is released while element has focus
    fn on_key_up(&mut self, _key: Key, _modifiers: Modifiers) {}

    // Focus handlers
    /// Called when element gains focus
    fn on_focus_in(&mut self) {}

    /// Called when element loses focus
    fn on_focus_out(&mut self) {}
}

/// Event handler closures for interactive elements
pub struct EventHandlers {
    // Mouse handlers
    pub on_mouse_enter: Option<Box<dyn FnMut()>>,
    pub on_mouse_leave: Option<Box<dyn FnMut()>>,
    pub on_mouse_move: Option<Box<dyn FnMut(Vec2, Vec2)>>,
    pub on_mouse_down: Option<Box<dyn FnMut(MouseButton, Vec2, Vec2)>>,
    pub on_mouse_up: Option<Box<dyn FnMut(MouseButton, Vec2, Vec2)>>,
    pub on_click: Option<Box<dyn FnMut(MouseButton, Vec2, Vec2)>>,
    pub on_scroll: Option<Box<dyn FnMut(Vec2, Vec2, Vec2)>>,
    // Keyboard handlers
    pub on_key_down: Option<Box<dyn FnMut(Key, Modifiers, Option<char>, bool)>>,
    pub on_key_up: Option<Box<dyn FnMut(Key, Modifiers)>>,
    // Focus handlers
    pub on_focus_in: Option<Box<dyn FnMut()>>,
    pub on_focus_out: Option<Box<dyn FnMut()>>,
}

impl EventHandlers {
    pub fn new() -> Self {
        Self {
            on_mouse_enter: None,
            on_mouse_leave: None,
            on_mouse_move: None,
            on_mouse_down: None,
            on_mouse_up: None,
            on_click: None,
            on_scroll: None,
            on_key_down: None,
            on_key_up: None,
            on_focus_in: None,
            on_focus_out: None,
        }
    }

    /// Set the mouse enter handler
    pub fn on_mouse_enter<F>(mut self, handler: F) -> Self
    where
        F: FnMut() + 'static,
    {
        self.on_mouse_enter = Some(Box::new(handler));
        self
    }

    /// Set the mouse leave handler
    pub fn on_mouse_leave<F>(mut self, handler: F) -> Self
    where
        F: FnMut() + 'static,
    {
        self.on_mouse_leave = Some(Box::new(handler));
        self
    }

    /// Set the mouse move handler
    pub fn on_mouse_move<F>(mut self, handler: F) -> Self
    where
        F: FnMut(Vec2, Vec2) + 'static,
    {
        self.on_mouse_move = Some(Box::new(handler));
        self
    }

    /// Set the mouse down handler
    pub fn on_mouse_down<F>(mut self, handler: F) -> Self
    where
        F: FnMut(MouseButton, Vec2, Vec2) + 'static,
    {
        self.on_mouse_down = Some(Box::new(handler));
        self
    }

    /// Set the mouse up handler
    pub fn on_mouse_up<F>(mut self, handler: F) -> Self
    where
        F: FnMut(MouseButton, Vec2, Vec2) + 'static,
    {
        self.on_mouse_up = Some(Box::new(handler));
        self
    }

    /// Set the click handler
    pub fn on_click<F>(mut self, handler: F) -> Self
    where
        F: FnMut(MouseButton, Vec2, Vec2) + 'static,
    {
        self.on_click = Some(Box::new(handler));
        self
    }

    /// Set the scroll handler
    pub fn on_scroll<F>(mut self, handler: F) -> Self
    where
        F: FnMut(Vec2, Vec2, Vec2) + 'static,
    {
        self.on_scroll = Some(Box::new(handler));
        self
    }

    /// Set the key down handler
    pub fn on_key_down<F>(mut self, handler: F) -> Self
    where
        F: FnMut(Key, Modifiers, Option<char>, bool) + 'static,
    {
        self.on_key_down = Some(Box::new(handler));
        self
    }

    /// Set the key up handler
    pub fn on_key_up<F>(mut self, handler: F) -> Self
    where
        F: FnMut(Key, Modifiers) + 'static,
    {
        self.on_key_up = Some(Box::new(handler));
        self
    }

    /// Set the focus in handler
    pub fn on_focus_in<F>(mut self, handler: F) -> Self
    where
        F: FnMut() + 'static,
    {
        self.on_focus_in = Some(Box::new(handler));
        self
    }

    /// Set the focus out handler
    pub fn on_focus_out<F>(mut self, handler: F) -> Self
    where
        F: FnMut() + 'static,
    {
        self.on_focus_out = Some(Box::new(handler));
        self
    }

    /// Process an interaction event
    pub fn handle_event(&mut self, event: &InteractionEvent) {
        match event {
            InteractionEvent::MouseEnter { .. } => {
                if let Some(handler) = &mut self.on_mouse_enter {
                    handler();
                }
            }
            InteractionEvent::MouseLeave { .. } => {
                if let Some(handler) = &mut self.on_mouse_leave {
                    handler();
                }
            }
            InteractionEvent::MouseMove {
                position,
                local_position,
                ..
            } => {
                if let Some(handler) = &mut self.on_mouse_move {
                    handler(*position, *local_position);
                }
            }
            InteractionEvent::MouseDown {
                button,
                position,
                local_position,
                ..
            } => {
                if let Some(handler) = &mut self.on_mouse_down {
                    handler(*button, *position, *local_position);
                }
            }
            InteractionEvent::MouseUp {
                button,
                position,
                local_position,
                ..
            } => {
                if let Some(handler) = &mut self.on_mouse_up {
                    handler(*button, *position, *local_position);
                }
            }
            InteractionEvent::Click {
                button,
                position,
                local_position,
                ..
            } => {
                if let Some(handler) = &mut self.on_click {
                    handler(*button, *position, *local_position);
                }
            }
            InteractionEvent::ScrollWheel {
                delta,
                position,
                local_position,
                ..
            } => {
                if let Some(handler) = &mut self.on_scroll {
                    handler(*delta, *position, *local_position);
                }
            }
            InteractionEvent::KeyDown {
                key,
                modifiers,
                character,
                is_repeat,
                ..
            } => {
                if let Some(handler) = &mut self.on_key_down {
                    handler(*key, *modifiers, *character, *is_repeat);
                }
            }
            InteractionEvent::KeyUp { key, modifiers, .. } => {
                if let Some(handler) = &mut self.on_key_up {
                    handler(*key, *modifiers);
                }
            }
            InteractionEvent::FocusIn { .. } => {
                if let Some(handler) = &mut self.on_focus_in {
                    handler();
                }
            }
            InteractionEvent::FocusOut { .. } => {
                if let Some(handler) = &mut self.on_focus_out {
                    handler();
                }
            }
            InteractionEvent::ShortcutTriggered { .. } => {
                // Shortcut events are handled at the application level, not element level
            }
        }
    }
}

impl Default for EventHandlers {
    fn default() -> Self {
        Self::new()
    }
}
