# July 9, 2025

I've been spending more time working on toy-ui - trying to get a better grasp on all the systems and pieces that work together to get pixels on the screen.

Admittedly, I've been a bit too "Claude take the wheel" and not spent enough time understanding each piece as I build. So I wanted to slow down and tackle one problem that has been bothering me: the startup time.

When I run an example or `cargo run` I've noticed that it was taking about 1000ms before anything appeared on screen. Running the main example with 4 layers - some text, boxes, and a "performance test" with 50 items - the frame rate was abysmal.

Time to investigate.

I started by adding some tracing via [`tracing`](https://docs.rs/tracing) and [`tracing-subscriber`](https://docs.rs/tracing-subscriber).

## Initial Trace Results

Running with `RUST_LOG=toy_ui=info cargo run` revealed the startup breakdown:

```
0.049642250s  INFO NSApplication initialized in 49.13375ms
0.055600042s  INFO App menu created in 5.923708ms
0.065099625s  INFO Metal device and command queue created in 9.472084ms
0.085271959s  INFO Window created in 20.1405ms
0.214771709s  INFO FontContext created in 126.294ms
0.217608209s  INFO Total TextSystem initialization: 129.134208ms
0.220552584s  INFO Total app build time: 220.063917ms
0.848007500s  INFO First frame rendered in 597.81275ms (total time since start: 627.338625ms)
```

The font system alone was taking 126ms to initialize. This seems like user error – I can't imagine that [xilem](https://github.com/xilem) takes this long to initialize their implementation of the font system (using [parley](https://github.com/xilem/parley), the font measurement and layout library they purpose built for xilem). So there are probably some improvements we can make there.

But the real killer is that 600ms to first frame. We should be rendering like... hundreds of frames in that amount of time. Something is off.

Subsequent frames weren't much better:

```
0.947789958s  INFO Layer manager render completed in 101.209833ms
1.048077333s  INFO Layer manager render completed in 98.823209ms
1.146764125s  INFO Layer manager render completed in 98.543834ms
```

100ms per frame means we're running at 10fps. That would be great if we were rendering a classic hand drawn animation, but for a ui framework that ain't gonna cut it.

Let's find out what is happening. With times this off, we are clearly recalculating one or more things every frame, or even multiple times per frame.

Looking at the trace output was revealing. During layout computation, the same text was being measured multiple times:

```
0.204511500s Measured text 'Row item 1' -> 126.19141x33.600002
0.204767625s Measured text 'Row item 1' -> 126.19141x33.600002
0.205089625s Measured text 'Row item 1' -> 126.19141x33.600002
0.205349500s Measured text 'Row item 1' -> 126.19141x33.600002
```

Looking at the layer rendering code, I found this in `TaffyUiLayer::render()`:

```rust
fn render(&mut self, /* params */) {
    // This was happening EVERY FRAME:
    let root_element = (self.render_fn)();
    let ui_context = UiContext::new(size, scale_factor).build(root_element);
    let draw_list = ui_context.render(text_system)?;

    renderer.render_draw_list(&draw_list, /* params */);
}
```

The `TaffyUiLayer` is a layer that uses the [`taffy`](https://crates.io/crates/taffy) layout engine to do css-style layout on a given layer.

From the code above we learn that every single frame we:

1. Rebuilt the entire UI tree from scratch
2. Recomputed all layouts
3. Re-measured all text (multiple times!)
4. Generated new draw commands

## Fix #1: Caching the Draw List

The first optimization was to cache the computed `DrawList`. I modified `TaffyUiLayer`:

```diff
pub struct TaffyUiLayer<F> {
    options: LayerOptions,
    render_fn: F,
+   cached_draw_list: Option<DrawList>,
+   cached_size: Option<Vec2>,
+   needs_rebuild: bool,
}
```

Then rewrote the render logic to use the cache:

```diff
fn render(&mut self, renderer: &mut MetalRenderer, /* params */) {
-   // This was happening EVERY FRAME:
-   let root_element = (self.render_fn)();
-   let ui_context = UiContext::new(size, scale_factor).build(root_element);
-   let draw_list = ui_context.render(text_system)?;
-
-   renderer.render_draw_list(&draw_list, /* params */);
+   let size_changed = self.cached_size != Some(size);
+   if size_changed {
+       self.needs_rebuild = true;
+       self.cached_size = Some(size);
+   }
+
+   if !self.needs_rebuild && self.cached_draw_list.is_some() {
+       debug!("Using cached draw list");
+       let cached_list = self.cached_draw_list.as_ref().unwrap();
+
+       renderer.render_draw_list(cached_list, /* params */);
+       return;
+   }
+
+   // Only rebuild when necessary
+   debug!("Rebuilding UI tree");
+   let root_element = (self.render_fn)();
+   let ui_context = UiContext::new(size, scale_factor).build(root_element);
+   let draw_list = ui_context.render(text_system)?;
+
+   self.cached_draw_list = Some(draw_list.clone());
+   self.needs_rebuild = false;
+
+   renderer.render_draw_list(&draw_list, /* params */);
}
```

## Fix #2: Text Measurement Caching

Even with UI tree caching, the first frame was still slow. The culprit was text measurement happening multiple times during layout. Taffy calls the measurement function multiple times during its layout algorithm.

I added a frame-based measurement cache to `TextSystem`:

```diff
+#[derive(Debug, Clone, Hash, PartialEq, Eq)]
+struct MeasurementCacheKey {
+    text: String,
+    font_stack: String,
+    size: u32,
+    weight: u16,
+    line_height: u32,
+    max_width: Option<u32>,
+    scale_factor: u32,
+}

pub struct TextSystem {
    font_context: FontContext,
    layout_context: LayoutContext,
    scale_context: ScaleContext,
    glyph_atlas: GlyphAtlas,
    font_id_cache: HashMap<Vec<u8>, u64>,
    next_font_id: u64,
    shaped_text_cache: HashMap<ShapedTextCacheKey, ShapedText>,
+   measurement_cache: HashMap<MeasurementCacheKey, Vec2>,
}
```

```diff
pub fn measure_text(&mut self, text: &str, config: &TextConfig,
                    max_width: Option<f32>, scale_factor: f32) -> Vec2 {
+   let cache_key = MeasurementCacheKey {
+       text: text.to_string(),
+       font_stack: format!("{:?}", config.font_stack),
+       size: (config.size * 100.0) as u32,
+       weight: config.weight.value() as u16,
+       line_height: (config.line_height * 100.0) as u32,
+       max_width: max_width.map(|w| (w * 100.0) as u32),
+       scale_factor: (scale_factor * 100.0) as u32,
+   };
+
+   if let Some(&cached_size) = self.measurement_cache.get(&cache_key) {
+       debug!("Using cached measurement for '{}' -> {}x{}",
+              text, cached_size.x, cached_size.y);
+       return cached_size;
+   }

    // ... actual measurement code ...

+   self.measurement_cache.insert(cache_key, size);
    size
}
```

The cache gets cleared at the start of each frame:

```rust
pub fn begin_frame(&mut self) {
    self.measurement_cache.clear();
}
```

## Fix #3: Layer Invalidation

To handle dynamic updates, I added an invalidation system:

```rust
pub trait Layer: Any {
    fn invalidate(&mut self) {
        // Default implementation does nothing
    }
}

impl<F> Layer for TaffyUiLayer<F> {
    fn invalidate(&mut self) {
        debug!("Invalidating TaffyUiLayer cache");
        self.needs_rebuild = true;
        self.cached_draw_list = None;
    }
}

impl LayerManager {
    pub fn invalidate_all(&mut self) {
        for (_, layer) in &mut self.layers {
            layer.invalidate();
        }
    }

    pub fn invalidate_layer(&mut self, z_index: i32) {
        if let Some((_, layer)) = self.layers.iter_mut()
            .find(|(_, l)| l.z_index() == z_index) {
            layer.invalidate();
        }
    }
}
```

## Results

After implementing the caching:

```
0.762873666s  INFO First frame rendered in 561.012084ms
0.775826583s  INFO Layer manager render completed in 884.417µs
0.778015500s  INFO Layer manager render completed in 701.792µs
0.793042833s  INFO Layer manager render completed in 761.625µs
```

Subsequent frames now render in under 1ms! The debug output confirms all layers are using cached draw lists:

```
0.801888291s DEBUG Using cached draw list
0.802320125s DEBUG Using cached draw list
0.802525916s DEBUG Using cached draw list
0.802799083s DEBUG Using cached draw list
```

## Remaining Performance Issues

The first frame still takes 560ms. Breaking it down:

1. **Font initialization (126ms)**: The `FontContext::new()` in Parley is doing a lot of system font enumeration. This could be deferred or done in a background thread.

2. **UI tree building (400ms+)**: Building the performance test layer with 50 items involves:
   - Creating 50+ Taffy nodes
   - Running layout computation with many text measurements
   - Generating draw commands for everything

Here's the hot path for the 50-item test:

```rust
// In main.rs, Layer 4
for i in 0..50 {
    let hue = i as f32 / 50.0;
    let color = Srgba::new(hue, 0.8, 0.9, 1.0);

    container = container.child(
        row()
            .gap(10.0)
            .child(group().bg(color).size(30.0, 20.0))
            .child(text(format!("Item {}", i + 1), TextStyle { /* ... */ }))
    );
}
```

Each item creates multiple nodes in the Taffy tree, and the layout algorithm has to solve constraints for all of them.

## What's Next

The 100x improvement for steady-state rendering is great, but that first frame needs work. Some ideas:

1. **Lazy font loading**: Move `FontContext` initialization off the critical path. This isn't ideal though, due to pop-in or layout shift that would be introduced by the font swapping. Maybe there is another solution?
2. **Progressive rendering**: Render visible content first, defer off-screen elements
3. **Pre-computed layouts**: For static content, compute layouts at compile time
4. **Batched draw calls**: The 50-item test generates 100+ individual draw commands

The architecture is now in place for good performance - we just need to optimize the initial setup cost.
